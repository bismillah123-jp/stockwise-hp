CREATE TABLE IF NOT EXISTS public.stock_events (
    id bigint GENERATED BY DEFAULT AS IDENTITY NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    date date NOT NULL,
    imei text NOT NULL,
    location_id uuid NOT NULL,
    phone_model_id uuid NOT NULL,
    event_type text NOT NULL,
    qty integer DEFAULT 1 NOT NULL,
    notes text,
    created_by uuid,
    metadata jsonb DEFAULT '{}'::jsonb NOT NULL
);

ALTER TABLE public.stock_events ENABLE ROW LEVEL SECURITY;

CREATE UNIQUE INDEX IF NOT EXISTS idx_stock_events_imei_date_type ON public.stock_events USING btree (imei, date, event_type);
CREATE INDEX IF NOT EXISTS idx_stock_events_date_loc_model ON public.stock_events USING btree (date, location_id, phone_model_id);

DO $$ 
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_constraint WHERE conname = 'stock_events_pkey') THEN
        ALTER TABLE public.stock_events ADD CONSTRAINT stock_events_pkey PRIMARY KEY (id);
    END IF;
END $$;

DO $$ 
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_constraint WHERE conname = 'stock_events_location_id_fkey') THEN
        ALTER TABLE public.stock_events ADD CONSTRAINT stock_events_location_id_fkey FOREIGN KEY (location_id) REFERENCES stock_locations(id) ON UPDATE CASCADE ON DELETE CASCADE;
    END IF;
END $$;

DO $$ 
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_constraint WHERE conname = 'stock_events_phone_model_id_fkey') THEN
        ALTER TABLE public.stock_events ADD CONSTRAINT stock_events_phone_model_id_fkey FOREIGN KEY (phone_model_id) REFERENCES phone_models(id) ON UPDATE CASCADE ON DELETE CASCADE;
    END IF;
END $$;

DO $$ 
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_constraint WHERE conname = 'stock_events_event_type_check') THEN
        ALTER TABLE public.stock_events ADD CONSTRAINT stock_events_event_type_check CHECK (event_type = ANY (ARRAY['masuk'::text, 'laku'::text, 'retur_in'::text, 'retur_out'::text, 'transfer_out'::text, 'transfer_in'::text, 'koreksi'::text]));
    END IF;
END $$;

CREATE OR REPLACE FUNCTION public.cascade_recalc_stock(
  p_from_date date,
  p_location_id uuid,
  p_phone_model_id uuid,
  p_imei text
)
RETURNS void AS $$
DECLARE
  v_current_date date := p_from_date;
  v_today date := CURRENT_DATE;
  v_prev_akhir integer := 0;
  v_current_morning_stock integer;
  v_current_incoming integer;
  v_current_sold integer;
  v_current_returns integer;
  v_current_transfer_in integer;
  v_current_transfer_out integer;
  v_current_koreksi integer;
  v_new_night_stock integer;
BEGIN
  IF p_from_date > '1900-01-01'::date THEN
    SELECT night_stock INTO v_prev_akhir
    FROM stock_entries
    WHERE date = p_from_date - INTERVAL '1 day'
      AND location_id = p_location_id
      AND phone_model_id = p_phone_model_id
      AND imei = p_imei;
    IF v_prev_akhir IS NULL THEN
      v_prev_akhir := 0;
    END IF;
  END IF;

  WHILE v_current_date <= v_today LOOP
    SELECT
      COALESCE(SUM(CASE WHEN se.event_type = 'masuk' THEN se.qty ELSE 0 END), 0),
      COALESCE(SUM(CASE WHEN se.event_type = 'laku' THEN se.qty ELSE 0 END), 0),
      COALESCE(SUM(CASE WHEN se.event_type = 'retur_in' THEN se.qty ELSE 0 END), 0),
      COALESCE(SUM(CASE WHEN se.event_type = 'retur_out' THEN se.qty ELSE 0 END), 0),
      COALESCE(SUM(CASE WHEN se.event_type = 'transfer_in' THEN se.qty ELSE 0 END), 0),
      COALESCE(SUM(CASE WHEN se.event_type = 'transfer_out' THEN se.qty ELSE 0 END), 0),
      COALESCE(SUM(CASE WHEN se.event_type = 'koreksi' THEN se.qty ELSE 0 END), 0)
    INTO
      v_current_incoming,
      v_current_sold,
      v_current_returns,
      v_current_transfer_out,
      v_current_transfer_in,
      v_current_transfer_out,
      v_current_koreksi
    FROM stock_events se
    WHERE se.date = v_current_date
      AND se.location_id = p_location_id
      AND se.phone_model_id = p_phone_model_id
      AND se.imei = p_imei;

    v_new_night_stock := v_prev_akhir + v_current_incoming + v_current_returns + v_current_transfer_in + v_current_koreksi - v_current_sold - v_current_transfer_out;

    INSERT INTO stock_entries (
      date, location_id, phone_model_id, imei,
      morning_stock, incoming, sold, returns, adjustment, night_stock
    )
    VALUES (
      v_current_date, p_location_id, p_phone_model_id, p_imei,
      v_prev_akhir, v_current_incoming, v_current_sold, v_current_returns, (v_current_transfer_in + v_current_koreksi - v_current_transfer_out), v_new_night_stock
    )
    ON CONFLICT (date, location_id, phone_model_id, imei) DO UPDATE SET
      morning_stock = EXCLUDED.morning_stock,
      incoming = EXCLUDED.incoming,
      sold = EXCLUDED.sold,
      returns = EXCLUDED.returns,
      adjustment = EXCLUDED.adjustment,
      night_stock = EXCLUDED.night_stock,
      updated_at = now();

    v_prev_akhir := v_new_night_stock;
    v_current_date := v_current_date + INTERVAL '1 day';
  END LOOP;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION public.trigger_cascade_recalc()
RETURNS TRIGGER AS $$
BEGIN
  PERFORM public.cascade_recalc_stock(
    COALESCE(NEW.date, OLD.date),
    COALESCE(NEW.location_id, OLD.location_id),
    COALESCE(NEW.phone_model_id, OLD.phone_model_id),
    COALESCE(NEW.imei, OLD.imei)
  );
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_cascade_after_event ON public.stock_events;
CREATE TRIGGER trg_cascade_after_event
AFTER INSERT OR UPDATE OR DELETE ON public.stock_events
FOR EACH ROW
EXECUTE FUNCTION public.trigger_cascade_recalc();

CREATE POLICY "Enable read access for all users" ON public.stock_events
    FOR SELECT USING (true);

CREATE POLICY "Enable insert for all users" ON public.stock_events
    FOR INSERT WITH CHECK (true);

CREATE POLICY "Enable update for all users" ON public.stock_events
    FOR UPDATE USING (true);

CREATE POLICY "Enable delete for all users" ON public.stock_events
    FOR DELETE USING (true);
