-- Run this SQL in your Supabase SQL Editor to create the missing tables

-- 1. Create stock_events table
CREATE TABLE IF NOT EXISTS public.stock_events (
    id bigint GENERATED BY DEFAULT AS IDENTITY NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    date date NOT NULL,
    imei text NOT NULL,
    location_id uuid NOT NULL,
    phone_model_id uuid NOT NULL,
    event_type text NOT NULL,
    qty integer DEFAULT 1 NOT NULL,
    notes text,
    created_by uuid,
    metadata jsonb DEFAULT '{}'::jsonb NOT NULL
);

-- 2. Add constraints
ALTER TABLE public.stock_events ENABLE ROW LEVEL SECURITY;

-- Create indexes
CREATE UNIQUE INDEX IF NOT EXISTS idx_stock_events_imei_date_type ON public.stock_events USING btree (imei, date, event_type);
CREATE INDEX IF NOT EXISTS idx_stock_events_date_loc_model ON public.stock_events USING btree (date, location_id, phone_model_id);

-- Add primary key
DO $$ 
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_constraint WHERE conname = 'stock_events_pkey') THEN
        ALTER TABLE public.stock_events ADD CONSTRAINT stock_events_pkey PRIMARY KEY (id);
    END IF;
END $$;

-- Add foreign key constraints
DO $$ 
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_constraint WHERE conname = 'stock_events_location_id_fkey') THEN
        ALTER TABLE public.stock_events ADD CONSTRAINT stock_events_location_id_fkey FOREIGN KEY (location_id) REFERENCES stock_locations(id) ON UPDATE CASCADE ON DELETE CASCADE;
    END IF;
END $$;

DO $$ 
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_constraint WHERE conname = 'stock_events_phone_model_id_fkey') THEN
        ALTER TABLE public.stock_events ADD CONSTRAINT stock_events_phone_model_id_fkey FOREIGN KEY (phone_model_id) REFERENCES phone_models(id) ON UPDATE CASCADE ON DELETE CASCADE;
    END IF;
END $$;

-- Add check constraint
DO $$ 
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_constraint WHERE conname = 'stock_events_event_type_check') THEN
        ALTER TABLE public.stock_events ADD CONSTRAINT stock_events_event_type_check CHECK (event_type = ANY (ARRAY['masuk'::text, 'laku'::text, 'retur_in'::text, 'retur_out'::text, 'transfer_out'::text, 'transfer_in'::text, 'koreksi'::text]));
    END IF;
END $$;

-- 3. Create cascade recalculation function
CREATE OR REPLACE FUNCTION public.cascade_recalc_stock(
  p_from_date date,
  p_location_id uuid,
  p_phone_model_id uuid,
  p_imei text
)
RETURNS void AS $$
DECLARE
  v_current_date date := p_from_date;
  v_today date := CURRENT_DATE;
  v_prev_akhir integer := 0;
  v_current_morning_stock integer;
  v_current_incoming integer;
  v_current_sold integer;
  v_current_returns integer;
  v_current_transfer_in integer;
  v_current_transfer_out integer;
  v_current_koreksi integer;
  v_new_night_stock integer;
BEGIN
  -- Get the night stock from the day before p_from_date to initialize v_prev_akhir
  IF p_from_date > '1900-01-01'::date THEN -- Arbitrary old date to avoid issues with very first day
    SELECT night_stock INTO v_prev_akhir
    FROM stock_entries
    WHERE date = p_from_date - INTERVAL '1 day'
      AND location_id = p_location_id
      AND phone_model_id = p_phone_model_id
      AND imei = p_imei;
    -- If no entry for previous day, assume 0
    IF v_prev_akhir IS NULL THEN
      v_prev_akhir := 0;
    END IF;
  END IF;

  -- Loop from p_from_date up to today
  WHILE v_current_date <= v_today LOOP
    -- Calculate day's events from stock_events for the specific IMEI
    SELECT
      COALESCE(SUM(CASE WHEN se.event_type = 'masuk' THEN se.qty ELSE 0 END), 0),
      COALESCE(SUM(CASE WHEN se.event_type = 'laku' THEN se.qty ELSE 0 END), 0),
      COALESCE(SUM(CASE WHEN se.event_type = 'retur_in' THEN se.qty ELSE 0 END), 0),
      COALESCE(SUM(CASE WHEN se.event_type = 'retur_out' THEN se.qty ELSE 0 END), 0),
      COALESCE(SUM(CASE WHEN se.event_type = 'transfer_in' THEN se.qty ELSE 0 END), 0),
      COALESCE(SUM(CASE WHEN se.event_type = 'transfer_out' THEN se.qty ELSE 0 END), 0),
      COALESCE(SUM(CASE WHEN se.event_type = 'koreksi' THEN se.qty ELSE 0 END), 0)
    INTO
      v_current_incoming,
      v_current_sold,
      v_current_returns,
      v_current_transfer_out, -- retur_out is equivalent to transfer_out in terms of stock reduction
      v_current_transfer_in,
      v_current_transfer_out, -- transfer_out is also a reduction
      v_current_koreksi
    FROM stock_events se
    WHERE se.date = v_current_date
      AND se.location_id = p_location_id
      AND se.phone_model_id = p_phone_model_id
      AND se.imei = p_imei;

    -- Calculate new night stock
    v_new_night_stock := v_prev_akhir + v_current_incoming + v_current_returns + v_current_transfer_in + v_current_koreksi - v_current_sold - v_current_transfer_out;

    -- Update or insert into stock_entries
    INSERT INTO stock_entries (
      date, location_id, phone_model_id, imei,
      morning_stock, incoming, sold, returns, adjustment, night_stock
    )
    VALUES (
      v_current_date, p_location_id, p_phone_model_id, p_imei,
      v_prev_akhir, v_current_incoming, v_current_sold, v_current_returns, (v_current_transfer_in + v_current_koreksi - v_current_transfer_out), v_new_night_stock
    )
    ON CONFLICT (date, location_id, phone_model_id, imei) DO UPDATE SET
      morning_stock = EXCLUDED.morning_stock,
      incoming = EXCLUDED.incoming,
      sold = EXCLUDED.sold,
      returns = EXCLUDED.returns,
      adjustment = EXCLUDED.adjustment,
      night_stock = EXCLUDED.night_stock,
      updated_at = now();

    -- Set v_prev_akhir for the next iteration
    v_prev_akhir := v_new_night_stock;
    v_current_date := v_current_date + INTERVAL '1 day';
  END LOOP;
END;
$$ LANGUAGE plpgsql;

-- 4. Create trigger function
CREATE OR REPLACE FUNCTION public.trigger_cascade_recalc()
RETURNS TRIGGER AS $$
BEGIN
  -- Call cascade_recalc_stock for the affected IMEI, location, and phone model
  PERFORM public.cascade_recalc_stock(
    COALESCE(NEW.date, OLD.date),
    COALESCE(NEW.location_id, OLD.location_id),
    COALESCE(NEW.phone_model_id, OLD.phone_model_id),
    COALESCE(NEW.imei, OLD.imei)
  );
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- 5. Create trigger
DROP TRIGGER IF EXISTS trg_cascade_after_event ON public.stock_events;
CREATE TRIGGER trg_cascade_after_event
AFTER INSERT OR UPDATE OR DELETE ON public.stock_events
FOR EACH ROW
EXECUTE FUNCTION public.trigger_cascade_recalc();

-- 6. Add RLS policies for stock_events
CREATE POLICY "Enable read access for all users" ON public.stock_events
    FOR SELECT USING (true);

CREATE POLICY "Enable insert for all users" ON public.stock_events
    FOR INSERT WITH CHECK (true);

CREATE POLICY "Enable update for all users" ON public.stock_events
    FOR UPDATE USING (true);

CREATE POLICY "Enable delete for all users" ON public.stock_events
    FOR DELETE USING (true);
